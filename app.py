# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nBa5POelLrR6GR0StBrCzU0c1k2hn3Gn
"""

# BrayFXTrade Analyzer - Streamlit App
# Save this file as app.py and run: streamlit run app.py

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import plotly.graph_objs as go
from plotly.subplots import make_subplots
from datetime import datetime, timedelta

st.set_page_config(layout="wide", page_title="BrayFXTrade Analyzer")

# ---------------------- Utility / Analysis Functions ----------------------

def fetch_data(ticker: str, start: str, end: str, interval: str = '1h') -> pd.DataFrame:
    """Fetch OHLCV data from yfinance and return cleaned DataFrame."""
    data = yf.download(ticker, start=start, end=end, interval=interval, progress=False)
    if data.empty:
        return data
    data = data[['Open', 'High', 'Low', 'Close', 'Volume']].dropna()
    data.index = pd.to_datetime(data.index)
    data = data.sort_index()
    return data


def detect_order_blocks(df: pd.DataFrame, lookback: int = 20) -> pd.DataFrame:
    """
    Simple heuristic to detect potential bullish/bearish order blocks:
    - Bullish OB: a bearish candle (Close < Open) followed by strong bullish continuation
    - Bearish OB: a bullish candle followed by strong bearish continuation
    Marks the high/low of the OB candle as level.
    Returns df with columns: OB_type (None/bull/bear), OB_level
    """
    df = df.copy()
    df['OB_type'] = None
    df['OB_level'] = np.nan

    # Look for a reversal candle followed by momentum candle
    for i in range(1, len(df)-1):
        prev = df.iloc[i-1]
        cur = df.iloc[i]
        nxt = df.iloc[i+1]
        # bullish OB: cur is bearish, next candle bullish with larger body
        body_cur = abs(cur.Close - cur.Open)
        body_nxt = abs(nxt.Close - nxt.Open)
        if cur.Close < cur.Open and nxt.Close > nxt.Open and body_nxt > body_cur * 0.8 and nxt.Close > cur.Open:
            df.at[df.index[i], 'OB_type'] = 'bull'
            df.at[df.index[i], 'OB_level'] = cur.Low  # use low as support
        # bearish OB
        elif cur.Close > cur.Open and nxt.Close < nxt.Open and body_nxt > body_cur * 0.8 and nxt.Close < cur.Open:
            df.at[df.index[i], 'OB_type'] = 'bear'
            df.at[df.index[i], 'OB_level'] = cur.High  # use high as resistance
    return df


def detect_fvg(df: pd.DataFrame) -> pd.DataFrame:
    """
    Detect basic Fair Value Gaps (FVG) using 3-candle structure (common retail heuristic):
    - Up-FVG (bullish gap): when candle1 high < candle3 low -> leaves gap between
    - Down-FVG (bearish gap): candle1 low > candle3 high
    We'll record gap top and bottom and the index where it occurs (at candle3)
    """
    df = df.copy()
    df['FVG'] = None
    df['FVG_top'] = np.nan
    df['FVG_bottom'] = np.nan

    for i in range(2, len(df)):
        c1 = df.iloc[i-2]
        c2 = df.iloc[i-1]
        c3 = df.iloc[i]
        # bullish gap (price moved up leaving space)
        if c1['High'] < c3['Low']:
            top = c3['Low']
            bottom = c1['High']
            df.at[df.index[i], 'FVG'] = 'bull'
            df.at[df.index[i], 'FVG_top'] = top
            df.at[df.index[i], 'FVG_bottom'] = bottom
        # bearish gap
        elif c1['Low'] > c3['High']:
            top = c1['Low']
            bottom = c3['High']
            df.at[df.index[i], 'FVG'] = 'bear'
            df.at[df.index[i], 'FVG_top'] = top
            df.at[df.index[i], 'FVG_bottom'] = bottom
    return df


def detect_patterns(df: pd.DataFrame) -> pd.DataFrame:
    """
    Detect simple chart patterns: double top / double bottom and support/resistance breakouts.
    Returns df with column 'pattern' and optionally pattern levels.
    """
    df = df.copy()
    df['pattern'] = None
    df['pattern_level'] = np.nan

    # Find local maxima/minima using rolling windows
    highs = df['High']
    lows = df['Low']
    window = 10

    local_max = (highs == highs.rolling(window, center=True, min_periods=1).max())
    local_min = (lows == lows.rolling(window, center=True, min_periods=1).min())

    # collect peaks
    peaks = df[local_max].index
    troughs = df[local_min].index

    # Check for double top: two peaks near same level separated by a trough
    for i in range(len(peaks)-1):
        p1 = peaks[i]
        p2 = peaks[i+1]
        # ensure there is at least one trough between
        between = troughs[(troughs > p1) & (troughs < p2)]
        if len(between) >= 1:
            level1 = df.at[p1, 'High']
            level2 = df.at[p2, 'High']
            if abs(level1 - level2) / max(level1, level2) < 0.01:  # within 1%
                # mark the second peak as double top
                df.at[p2, 'pattern'] = 'double_top'
                df.at[p2, 'pattern_level'] = (level1 + level2) / 2

    # Double bottom
    for i in range(len(troughs)-1):
        t1 = troughs[i]
        t2 = troughs[i+1]
        between = peaks[(peaks > t1) & (peaks < t2)]
        if len(between) >= 1:
            level1 = df.at[t1, 'Low']
            level2 = df.at[t2, 'Low']
            if abs(level1 - level2) / max(level1, level2) < 0.01:
                df.at[t2, 'pattern'] = 'double_bottom'
                df.at[t2, 'pattern_level'] = (level1 + level2) / 2

    return df


def generate_signals(df: pd.DataFrame, strategy: str = 'OB+FVG') -> pd.DataFrame:
    """
    Combine OB, FVG and pattern detections into entry signals.
    Strategy examples:
    - 'OB' : trade on order blocks
    - 'FVG': trade on fair value gaps
    - 'OB+FVG': require both
    Returns df with signals: 'signal' column (long/short/none) and Entry/SL/TP
    """
    df = df.copy()
    df['signal'] = None
    df['entry'] = np.nan
    df['sl'] = np.nan
    df['tp'] = np.nan

    for i in range(len(df)):
        row = df.iloc[i]
        # prioritize pattern breakouts
        if pd.notna(row.get('pattern')):
            if row['pattern'] == 'double_bottom':
                # long entry = next candle open, sl = pattern low, tp = risk*2
                entry = row['Close']
                sl = row['pattern_level'] * 0.995
                rr = 2.0
                tp = entry + (entry - sl) * rr
                df.at[df.index[i], 'signal'] = 'long'
                df.at[df.index[i], 'entry'] = entry
                df.at[df.index[i], 'sl'] = sl
                df.at[df.index[i], 'tp'] = tp
            elif row['pattern'] == 'double_top':
                entry = row['Close']
                sl = row['pattern_level'] * 1.005
                rr = 2.0
                tp = entry - (sl - entry) * rr
                df.at[df.index[i], 'signal'] = 'short'
                df.at[df.index[i], 'entry'] = entry
                df.at[df.index[i], 'sl'] = sl
                df.at[df.index[i], 'tp'] = tp
        # OB/FVG based signals
        ob = row.get('OB_type')
        fvg = row.get('FVG')
        if strategy == 'OB' and pd.notna(ob):
            if ob == 'bull':
                entry = row['Close']
                sl = row['OB_level'] * 0.995
                tp = entry + (entry - sl) * 2
                df.at[df.index[i], 'signal'] = 'long'
                df.at[df.index[i], 'entry'] = entry
                df.at[df.index[i], 'sl'] = sl
                df.at[df.index[i], 'tp'] = tp
            elif ob == 'bear':
                entry = row['Close']
                sl = row['OB_level'] * 1.005
                tp = entry - (sl - entry) * 2
                df.at[df.index[i], 'signal'] = 'short'
                df.at[df.index[i], 'entry'] = entry
                df.at[df.index[i], 'sl'] = sl
                df.at[df.index[i], 'tp'] = tp
        elif strategy == 'FVG' and pd.notna(fvg):
            if fvg == 'bull':
                entry = row['Close']
                sl = row['FVG_bottom'] * 0.995
                tp = entry + (entry - sl) * 2
                df.at[df.index[i], 'signal'] = 'long'
                df.at[df.index[i], 'entry'] = entry
                df.at[df.index[i], 'sl'] = sl
                df.at[df.index[i], 'tp'] = tp
            elif fvg == 'bear':
                entry = row['Close']
                sl = row['FVG_top'] * 1.005
                tp = entry - (sl - entry) * 2
                df.at[df.index[i], 'signal'] = 'short'
                df.at[df.index[i], 'entry'] = entry
                df.at[df.index[i], 'sl'] = sl
                df.at[df.index[i], 'tp'] = tp
        elif strategy == 'OB+FVG' and pd.notna(ob) and pd.notna(fvg) and ob == 'bull' and fvg == 'bull':
            entry = row['Close']
            sl = min(row['OB_level'], row['FVG_bottom']) * 0.995
            tp = entry + (entry - sl) * 2
            df.at[df.index[i], 'signal'] = 'long'
            df.at[df.index[i], 'entry'] = entry
            df.at[df.index[i], 'sl'] = sl
            df.at[df.index[i], 'tp'] = tp
        elif strategy == 'OB+FVG' and pd.notna(ob) and pd.notna(fvg) and ob == 'bear' and fvg == 'bear':
            entry = row['Close']
            sl = max(row['OB_level'], row['FVG_top']) * 1.005
            tp = entry - (sl - entry) * 2
            df.at[df.index[i], 'signal'] = 'short'
            df.at[df.index[i], 'entry'] = entry
            df.at[df.index[i], 'sl'] = sl
            df.at[df.index[i], 'tp'] = tp

    return df


def backtest_signals(df: pd.DataFrame, look_forward: int = 24) -> pd.DataFrame:
    """
    For each generated signal, look forward N bars and determine whether TP or SL was hit first.
    We'll simulate naive price path using High/Low of forward bars.
    Adds columns: outcome (win/loss/na), profit (pips/price diff)
    """
    df = df.copy()
    df['outcome'] = None
    df['profit'] = np.nan

    for i in range(len(df)):
        sig = df.iloc[i].get('signal')
        if pd.isna(sig):
            continue
        entry = df.iloc[i]['entry']
        sl = df.iloc[i]['sl']
        tp = df.iloc[i]['tp']
        # scan forward
        end = min(len(df)-1, i + look_forward)
        hit = None
        for j in range(i+1, end+1):
            high = df.iloc[j]['High']
            low = df.iloc[j]['Low']
            if sig == 'long':
                # check SL then TP order not important; whichever hits first
                if low <= sl and high >= tp:
                    # both hit in same candle -> decide by closeness: whichever is crossed earlier (approx)
                    # approximate by distances
                    dist_sl = entry - sl
                    dist_tp = tp - entry
                    if dist_tp >= dist_sl:
                        hit = 'win'
                        profit = tp - entry
                    else:
                        hit = 'loss'
                        profit = sl - entry
                elif low <= sl:
                    hit = 'loss'
                    profit = sl - entry
                elif high >= tp:
                    hit = 'win'
                    profit = tp - entry
            elif sig == 'short':
                if high >= sl and low <= tp:
                    dist_sl = sl - entry
                    dist_tp = entry - tp
                    if dist_tp >= dist_sl:
                        hit = 'win'
                        profit = entry - tp
                    else:
                        hit = 'loss'
                        profit = entry - sl
                elif high >= sl:
                    hit = 'loss'
                    profit = entry - sl
                elif low <= tp:
                    hit = 'win'
                    profit = entry - tp
            if hit is not None:
                df.at[df.index[i], 'outcome'] = hit
                df.at[df.index[i], 'profit'] = profit
                break
        # if not hit within look_forward, label as 'no_hit' and mark profit as close-to-last
        if pd.isna(df.at[df.index[i], 'outcome']):
            last_close = df.iloc[end]['Close']
            if sig == 'long':
                df.at[df.index[i], 'outcome'] = 'no_hit'
                df.at[df.index[i], 'profit'] = last_close - entry
            else:
                df.at[df.index[i], 'outcome'] = 'no_hit'
                df.at[df.index[i], 'profit'] = entry - last_close

    return df


# ---------------------- Streamlit UI ----------------------

st.title("BrayFXTrade Analyzer")

with st.sidebar:
    st.header("Settings")
    pair = st.selectbox("Pair / Ticker (Yahoo Finance)", options=["EURUSD=X", "GBPUSD=X", "USDJPY=X", "BTC-USD", "ETH-USD", "AAPL"], index=0)
    interval = st.selectbox("Interval", options=["1h", "30m", "1d"], index=0)
    # strategies and modes
    strategy = st.selectbox("Strategy", options=["OB+FVG", "OB", "FVG", "Patterns"], index=0)
    mode = st.selectbox("Mode", options=["Signal Generation", "Backtest"], index=1)

    today = datetime.utcnow().date()
    default_start = today - timedelta(days=90)
    start_date = st.date_input("Start Date", default_start)
    end_date = st.date_input("End Date", today)

    look_forward = st.number_input("Backtest look-forward bars", min_value=1, max_value=500, value=48)
    run_button = st.button("Run Analysis")

# Info/helper
st.markdown("""
This app downloads OHLCV from Yahoo Finance (via `yfinance`), detects simple Order Blocks (OB), Fair Value Gaps (FVG), and a couple
of chart patterns (double top / double bottom). It then generates signals based on the selected strategy and optionally backtests them
by looking forward N bars to see if TP or SL was hit first.

**Note:** This is a heuristic demo — treat results as illustrative, not financial advice.
""")

if run_button:
    with st.spinner("Fetching data..."):
        df = fetch_data(pair, start_date.strftime('%Y-%m-%d'), (end_date + timedelta(days=1)).strftime('%Y-%m-%d'), interval=interval)
    if df.empty:
        st.error("No data found for the selected pair/interval/date range. Try different options.")
    else:
        # Run detection
        df_ob = detect_order_blocks(df, lookback=20)
        df_fvg = detect_fvg(df_ob)
        df_pat = detect_patterns(df_fvg)
        df_sig = generate_signals(df_pat, strategy=strategy)

        if mode == 'Backtest':
            df_bt = backtest_signals(df_sig, look_forward=look_forward)
        else:
            df_bt = df_sig.copy()

        # Performance summary
        total_signals = df_bt['signal'].notna().sum()
        wins = (df_bt['outcome'] == 'win').sum()
        losses = (df_bt['outcome'] == 'loss').sum()
        no_hits = (df_bt['outcome'] == 'no_hit').sum()
        win_rate = (wins / (wins + losses)) * 100 if (wins + losses) > 0 else np.nan
        avg_profit = df_bt['profit'].dropna().mean()

        col1, col2, col3, col4 = st.columns(4)
        col1.metric("Total Signals", int(total_signals))
        col2.metric("Wins", int(wins))
        col3.metric("Losses", int(losses))
        col4.metric("Win Rate", f"{win_rate:.2f}%" if not np.isnan(win_rate) else "N/A")

        st.subheader("Signals Table")
        display_cols = ['Open', 'High', 'Low', 'Close', 'Volume', 'OB_type', 'FVG', 'pattern', 'signal', 'entry', 'sl', 'tp', 'outcome', 'profit']
        st.dataframe(df_bt.reset_index()[['index'] + [c for c in display_cols if c in df_bt.columns]].rename(columns={'index':'Datetime'}).sort_values('Datetime', ascending=False))

        # Chart: Candlestick with OB / FVG / pattern markers
        st.subheader("Chart & Signals")
        fig = make_subplots(rows=2, cols=1, shared_xaxes=True, row_heights=[0.75, 0.25], vertical_spacing=0.02)

        fig.add_trace(go.Candlestick(x=df_bt.index, open=df_bt['Open'], high=df_bt['High'], low=df_bt['Low'], close=df_bt['Close'], name='Price'), row=1, col=1)

        # plot OB levels
        ob_bull = df_bt[df_bt['OB_type'] == 'bull']
        ob_bear = df_bt[df_bt['OB_type'] == 'bear']
        if not ob_bull.empty:
            fig.add_trace(go.Scatter(x=ob_bull.index, y=ob_bull['OB_level'], mode='markers+text', name='OB Bull', text=['OB Bull']*len(ob_bull), textposition='top center', marker=dict(symbol='triangle-up', size=10)), row=1, col=1)
        if not ob_bear.empty:
            fig.add_trace(go.Scatter(x=ob_bear.index, y=ob_bear['OB_level'], mode='markers+text', name='OB Bear', text=['OB Bear']*len(ob_bear), textposition='bottom center', marker=dict(symbol='triangle-down', size=10)), row=1, col=1)

        # plot FVG rectangles
        fvg_df = df_bt.dropna(subset=['FVG'])
        for idx, r in fvg_df.iterrows():
            top = r['FVG_top']
            bottom = r['FVG_bottom']
            if pd.notna(top) and pd.notna(bottom):
                fig.add_shape(type='rect', x0=idx - pd.Timedelta(interval), x1=idx, y0=bottom, y1=top, line=dict(width=0), fillcolor='LightSalmon' if r['FVG']=='bear' else 'LightGreen', opacity=0.15, row=1, col=1)

        # plot signals
        sigs = df_bt.dropna(subset=['signal'])
        longs = sigs[sigs['signal']=='long']
        shorts = sigs[sigs['signal']=='short']
        if not longs.empty:
            fig.add_trace(go.Scatter(x=longs.index, y=longs['entry'], mode='markers', name='Long Entry', marker=dict(symbol='circle', size=9)), row=1, col=1)
        if not shorts.empty:
            fig.add_trace(go.Scatter(x=shorts.index, y=shorts['entry'], mode='markers', name='Short Entry', marker=dict(symbol='x', size=9)), row=1, col=1)

        # volume
        fig.add_trace(go.Bar(x=df_bt.index, y=df_bt['Volume'], name='Volume'), row=2, col=1)

        fig.update_layout(height=700, showlegend=True, xaxis_rangeslider_visible=False, title_text=f"{pair} — {strategy} — {interval}")
        st.plotly_chart(fig, use_container_width=True)

        # Performance comparison graphs
        st.subheader("Performance & Distribution")
        perf_col1, perf_col2 = st.columns(2)

        # equity curve (cumulative profit of signals over time)
        signals_only = df_bt.dropna(subset=['signal']).copy()
        signals_only['cum_profit'] = signals_only['profit'].cumsum()
        if not signals_only.empty:
            perf_fig = go.Figure()
            perf_fig.add_trace(go.Scatter(x=signals_only.index, y=signals_only['cum_profit'], mode='lines+markers', name='Equity Curve'))
            perf_fig.update_layout(title='Equity Curve (by signals)', xaxis_title='Datetime', yaxis_title='Cumulative Profit')
            perf_col1.plotly_chart(perf_fig, use_container_width=True)

            # profit distribution
            hist_fig = go.Figure()
            hist_fig.add_trace(go.Histogram(x=signals_only['profit'], nbinsx=30))
            hist_fig.update_layout(title='Profit Distribution (per signal)', xaxis_title='Profit', yaxis_title='Count')
            perf_col2.plotly_chart(hist_fig, use_container_width=True)
        else:
            perf_col1.info('No signals to display performance charts.')

        # Summary and notes
        st.subheader("Summary & Guidance")
        st.write(f"Total signals: {total_signals}")
        st.write(f"Wins: {wins}  |  Losses: {losses}  |  No-hit: {no_hits}")
        st.write(f"Average profit per signal: {avg_profit:.5f}" if not np.isnan(avg_profit) else "Average profit: N/A")
        st.markdown("""
        **How entries/SL/TP are calculated (heuristic):**
        - Pattern breakouts: entry at close of the pattern candle, SL around pattern level, TP set as 2x reward-to-risk.
        - OB: entry at candle close where OB detected; SL at OB low/high; TP = 2*RR.
        - FVG: entry at close where gap detected; SL at gap edge; TP = 2*RR.

        These are simple heuristics meant to be a starting point. You should refine rules (confirmation candles, volume filters, time filters)
        before deploying any real money.
        """)

        st.success("Analysis complete. Review signals and charts above.")

else:
    st.info("Configure settings in the sidebar and click 'Run Analysis' to begin.")

# ---------------------- Footer / Help ----------------------
st.markdown("---")
st.markdown("Built by BrayFXTrade Analyzer — demo heuristics for OB/FVG and simple pattern detection.")

# End of file

!pip install streamlit yfinance plotly

!streamlit run app.py