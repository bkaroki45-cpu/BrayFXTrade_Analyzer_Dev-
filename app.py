# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nBa5POelLrR6GR0StBrCzU0c1k2hn3Gn
"""

# BrayFXTrade Analyzer - Streamlit App
# Save this file as app.py and run: streamlit run app.py

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as npgive 
import plotly.graph_objs as go
from plotly.subplots import make_subplots
from datetime import datetime, timedelta, timezone

st.set_page_config(layout="wide", page_title="BrayFXTrade Analyzer")

# ---------------------- Utility / Analysis Functions ----------------------

def fetch_data(ticker: str, start: str, end: str, interval: str = '1h') -> pd.DataFrame:
    """Fetch OHLCV data from yfinance and return cleaned DataFrame."""
    data = yf.download(ticker, start=start, end=end, interval=interval, progress=False)
    if data.empty:
        return data
    data = data[['Open', 'High', 'Low', 'Close', 'Volume']].dropna()
    data.index = pd.to_datetime(data.index)
    data = data.sort_index()
    return data


def detect_order_blocks(df: pd.DataFrame, lookback: int = 20) -> pd.DataFrame:
    """
    Detect bullish/bearish order blocks safely.
    """
    df = df.copy()
    df = df.dropna(subset=['Open', 'Close', 'High', 'Low'])

    df['OB_type'] = None
    df['OB_level'] = np.nan

    for i in range(1, len(df)-1):
        cur = df.iloc[i]
        nxt = df.iloc[i+1]

        body_cur = abs(cur['Close'] - cur['Open'])
        body_nxt = abs(nxt['Close'] - nxt['Open'])

        # bullish OB
        if float(cur['Close']) < float(cur['Open']) and \
           float(nxt['Close']) > float(nxt['Open']) and \
           body_nxt > body_cur * 0.8 and \
           float(nxt['Close']) > float(cur['Open']):
            df.at[df.index[i], 'OB_type'] = 'bull'
            df.at[df.index[i], 'OB_level'] = float(cur['Low'])

        # bearish OB
        elif float(cur['Close']) > float(cur['Open']) and \
             float(nxt['Close']) < float(nxt['Open']) and \
             body_nxt > body_cur * 0.8 and \
             float(nxt['Close']) < float(cur['Open']):
            df.at[df.index[i], 'OB_type'] = 'bear'
            df.at[df.index[i], 'OB_level'] = float(cur['High'])

    return df


  


def detect_fvg(df: pd.DataFrame) -> pd.DataFrame:
    """
    Detect basic Fair Value Gaps (FVG) using 3-candle structure.
    """
    df = df.copy()
    df = df.dropna(subset=['Open', 'High', 'Low', 'Close'])

    df['FVG'] = None
    df['FVG_top'] = np.nan
    df['FVG_bottom'] = np.nan

    for i in range(2, len(df)):
        c1 = df.iloc[i-2]
        c2 = df.iloc[i-1]
        c3 = df.iloc[i]

        # bullish gap
        if float(c1['High']) < float(c3['Low']):
            df.at[df.index[i], 'FVG'] = 'bull'
            df.at[df.index[i], 'FVG_top'] = float(c3['Low'])
            df.at[df.index[i], 'FVG_bottom'] = float(c1['High'])
        # bearish gap
        elif float(c1['Low']) > float(c3['High']):
            df.at[df.index[i], 'FVG'] = 'bear'
            df.at[df.index[i], 'FVG_top'] = float(c1['Low'])
            df.at[df.index[i], 'FVG_bottom'] = float(c3['High'])

    return df




def detect_patterns(df: pd.DataFrame) -> pd.DataFrame:
    """
    Detect simple chart patterns: double top / double bottom and support/resistance breakouts.
    """
    df = df.copy()
    df['pattern'] = None
    df['pattern_level'] = np.nan

    highs = df['High']
    lows = df['Low']
    window = 10

    local_max = (highs == highs.rolling(window, center=True, min_periods=1).max())
    local_min = (lows == lows.rolling(window, center=True, min_periods=1).min())

    peaks = df[local_max].index
    troughs = df[local_min].index

    # Double top
    for i in range(len(peaks)-1):
        p1 = peaks[i]
        p2 = peaks[i+1]
        between = troughs[(troughs > p1) & (troughs < p2)]
        if len(between) >= 1:
            level1 = df.at[p1, 'High']
            level2 = df.at[p2, 'High']
            if abs(level1 - level2) / max(level1, level2) < 0.01:
                df.at[p2, 'pattern'] = 'double_top'
                df.at[p2, 'pattern_level'] = (level1 + level2) / 2

    # Double bottom
    for i in range(len(troughs)-1):
        t1 = troughs[i]
        t2 = troughs[i+1]
        between = peaks[(peaks > t1) & (peaks < t2)]
        if len(between) >= 1:
            level1 = df.at[t1, 'Low']
            level2 = df.at[t2, 'Low']
            if abs(level1 - level2) / max(level1, level2) < 0.01:
                df.at[t2, 'pattern'] = 'double_bottom'
                df.at[t2, 'pattern_level'] = (level1 + level2) / 2

    return df






def backtest_signals(df: pd.DataFrame, look_forward: int = 24) -> pd.DataFrame:
    """
    For each generated signal, look forward N bars and determine whether TP or SL was hit first.
    """
    df = df.copy()
    df['outcome'] = None
    df['profit'] = np.nan

    for i in range(len(df)):
        sig = df.iloc[i].get('signal')
        entry = df.iloc[i].get('entry')
        sl = df.iloc[i].get('sl')
        tp = df.iloc[i].get('tp')
        
        if pd.isna(sig) or pd.isna(entry) or pd.isna(sl) or pd.isna(tp):
            continue

        end = min(len(df)-1, i + look_forward)
        hit = None

        for j in range(i+1, end+1):
            high = df.iloc[j]['High']
            low = df.iloc[j]['Low']

            if sig.lower() == 'long':
                if low <= sl and high >= tp:
                    if (tp - entry) >= (entry - sl):
                        hit = 'win'
                        profit = tp - entry
                    else:
                        hit = 'loss'
                        profit = sl - entry
                elif low <= sl:
                    hit = 'loss'
                    profit = sl - entry
                elif high >= tp:
                    hit = 'win'
                    profit = tp - entry

            elif sig.lower() == 'short':
                if high >= sl and low <= tp:
                    if (entry - tp) >= (sl - entry):
                        hit = 'win'
                        profit = entry - tp
                    else:
                        hit = 'loss'
                        profit = entry - sl
                elif high >= sl:
                    hit = 'loss'
                    profit = entry - sl
                elif low <= tp:
                    hit = 'win'
                    profit = entry - tp

            if hit is not None:
                df.at[df.index[i], 'outcome'] = hit
                df.at[df.index[i], 'profit'] = profit
                break

        if pd.isna(df.at[df.index[i], 'outcome']):
            last_close = df.iloc[end]['Close']
            if sig.lower() == 'long':
                df.at[df.index[i], 'outcome'] = 'no_hit'
                df.at[df.index[i], 'profit'] = last_close - entry
            elif sig.lower() == 'short':
                df.at[df.index[i], 'outcome'] = 'no_hit'
                df.at[df.index[i], 'profit'] = entry - last_close

    return df




# ---------------------- Streamlit UI ----------------------

st.title("BrayFXTrade Analyzer")

with st.sidebar:
    st.header("Settings")
    pair = st.selectbox("Pair / Ticker (Yahoo Finance)", options=["EURUSD=X", "GBPUSD=X", "USDJPY=X", "BTC-USD", "ETH-USD", "AAPL"], index=0)
    interval = st.selectbox("Interval", options=["1h", "30m", "1d"], index=0)
    # strategies and modes
    strategy = st.selectbox("Strategy", options=["OB+FVG", "OB", "FVG", "Patterns"], index=0)
    mode = st.selectbox("Mode", options=["Signal Generation", "Backtest"], index=1)

    today = datetime.utcnow().date()
    default_start = today - timedelta(days=90)
    start_date = st.date_input("Start Date", default_start)
    end_date = st.date_input("End Date", today)

    look_forward = st.number_input("Backtest look-forward bars", min_value=1, max_value=500, value=48)
    run_button = st.button("Run Analysis")

# Info/helper
st.markdown("""
This app downloads OHLCV from Yahoo Finance (via `yfinance`), detects simple Order Blocks (OB), Fair Value Gaps (FVG), and a couple
of chart patterns (double top / double bottom). It then generates signals based on the selected strategy and optionally backtests them
by looking forward N bars to see if TP or SL was hit first.

**Note:** This is a heuristic demo — treat results as illustrative, not financial advice.
""")

if run_button:
    with st.spinner("Fetching data..."):
        df = fetch_data(pair, start_date.strftime('%Y-%m-%d'), (end_date + timedelta(days=1)).strftime('%Y-%m-%d'), interval=interval)
    if df.empty:
        st.error("No data found for the selected pair/interval/date range. Try different options.")
    else:
        # Run detection
        df_ob = detect_order_blocks(df, lookback=20)
        df_fvg = detect_fvg(df_ob)
        df_pat = detect_patterns(df_fvg)
        df_sig = generate_signals(df_pat, strategy=strategy)

        if mode == 'Backtest':
            df_bt = backtest_signals(df_sig, look_forward=look_forward)
        else:
            df_bt = df_sig.copy()

        # Performance summary
        total_signals = df_bt['signal'].notna().sum()
        wins = (df_bt['outcome'] == 'win').sum()
        losses = (df_bt['outcome'] == 'loss').sum()
        no_hits = (df_bt['outcome'] == 'no_hit').sum()
        win_rate = (wins / (wins + losses)) * 100 if (wins + losses) > 0 else np.nan
        avg_profit = df_bt['profit'].dropna().mean()

        col1, col2, col3, col4 = st.columns(4)
        col1.metric("Total Signals", int(total_signals))
        col2.metric("Wins", int(wins))
        col3.metric("Losses", int(losses))
        col4.metric("Win Rate", f"{win_rate:.2f}%" if not np.isnan(win_rate) else "N/A")

        st.subheader("Signals Table")
        display_cols = ['Open', 'High', 'Low', 'Close', 'Volume', 'OB_type', 'FVG', 'pattern', 'signal', 'entry', 'sl', 'tp', 'outcome', 'profit']
        st.dataframe(df_bt.reset_index()[['index'] + [c for c in display_cols if c in df_bt.columns]].rename(columns={'index':'Datetime'}).sort_values('Datetime', ascending=False))

        # Chart: Candlestick with OB / FVG / pattern markers
        st.subheader("Chart & Signals")
        fig = make_subplots(rows=2, cols=1, shared_xaxes=True, row_heights=[0.75, 0.25], vertical_spacing=0.02)

        fig.add_trace(go.Candlestick(x=df_bt.index, open=df_bt['Open'], high=df_bt['High'], low=df_bt['Low'], close=df_bt['Close'], name='Price'), row=1, col=1)

        # plot OB levels
        ob_bull = df_bt[df_bt['OB_type'] == 'bull']
        ob_bear = df_bt[df_bt['OB_type'] == 'bear']
        if not ob_bull.empty:
            fig.add_trace(go.Scatter(x=ob_bull.index, y=ob_bull['OB_level'], mode='markers+text', name='OB Bull', text=['OB Bull']*len(ob_bull), textposition='top center', marker=dict(symbol='triangle-up', size=10)), row=1, col=1)
        if not ob_bear.empty:
            fig.add_trace(go.Scatter(x=ob_bear.index, y=ob_bear['OB_level'], mode='markers+text', name='OB Bear', text=['OB Bear']*len(ob_bear), textposition='bottom center', marker=dict(symbol='triangle-down', size=10)), row=1, col=1)

        # plot FVG rectangles
        fvg_df = df_bt.dropna(subset=['FVG'])
        for idx, r in fvg_df.iterrows():
            top = r['FVG_top']
            bottom = r['FVG_bottom']
            if pd.notna(top) and pd.notna(bottom):
                fig.add_shape(type='rect', x0=idx - pd.Timedelta(interval), x1=idx, y0=bottom, y1=top, line=dict(width=0), fillcolor='LightSalmon' if r['FVG']=='bear' else 'LightGreen', opacity=0.15, row=1, col=1)

        # plot signals
        sigs = df_bt.dropna(subset=['signal'])
        longs = sigs[sigs['signal']=='long']
        shorts = sigs[sigs['signal']=='short']
        if not longs.empty:
            fig.add_trace(go.Scatter(x=longs.index, y=longs['entry'], mode='markers', name='Long Entry', marker=dict(symbol='circle', size=9)), row=1, col=1)
        if not shorts.empty:
            fig.add_trace(go.Scatter(x=shorts.index, y=shorts['entry'], mode='markers', name='Short Entry', marker=dict(symbol='x', size=9)), row=1, col=1)

        # volume
        fig.add_trace(go.Bar(x=df_bt.index, y=df_bt['Volume'], name='Volume'), row=2, col=1)

        fig.update_layout(height=700, showlegend=True, xaxis_rangeslider_visible=False, title_text=f"{pair} — {strategy} — {interval}")
        st.plotly_chart(fig, use_container_width=True)

        # Performance comparison graphs
        st.subheader("Performance & Distribution")
        perf_col1, perf_col2 = st.columns(2)

        # equity curve (cumulative profit of signals over time)
        signals_only = df_bt.dropna(subset=['signal']).copy()
        signals_only['cum_profit'] = signals_only['profit'].cumsum()
        if not signals_only.empty:
            perf_fig = go.Figure()
            perf_fig.add_trace(go.Scatter(x=signals_only.index, y=signals_only['cum_profit'], mode='lines+markers', name='Equity Curve'))
            perf_fig.update_layout(title='Equity Curve (by signals)', xaxis_title='Datetime', yaxis_title='Cumulative Profit')
            perf_col1.plotly_chart(perf_fig, use_container_width=True)

            # profit distribution
            hist_fig = go.Figure()
            hist_fig.add_trace(go.Histogram(x=signals_only['profit'], nbinsx=30))
            hist_fig.update_layout(title='Profit Distribution (per signal)', xaxis_title='Profit', yaxis_title='Count')
            perf_col2.plotly_chart(hist_fig, use_container_width=True)
        else:
            perf_col1.info('No signals to display performance charts.')

        # Summary and notes
        st.subheader("Summary & Guidance")
        st.write(f"Total signals: {total_signals}")
        st.write(f"Wins: {wins}  |  Losses: {losses}  |  No-hit: {no_hits}")
        st.write(f"Average profit per signal: {avg_profit:.5f}" if not np.isnan(avg_profit) else "Average profit: N/A")
        st.markdown("""
        **How entries/SL/TP are calculated (heuristic):**
        - Pattern breakouts: entry at close of the pattern candle, SL around pattern level, TP set as 2x reward-to-risk.
        - OB: entry at candle close where OB detected; SL at OB low/high; TP = 2*RR.
        - FVG: entry at close where gap detected; SL at gap edge; TP = 2*RR.

        These are simple heuristics meant to be a starting point. You should refine rules (confirmation candles, volume filters, time filters)
        before deploying any real money.
        """)

        st.success("Analysis complete. Review signals and charts above.")

else:
    st.info("Configure settings in the sidebar and click 'Run Analysis' to begin.")

# ---------------------- Footer / Help ----------------------
st.markdown("---")
st.markdown("Built by BrayFXTrade Analyzer — demo heuristics for OB/FVG and simple pattern detection.")

# End of file